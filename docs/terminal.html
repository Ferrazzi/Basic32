<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Basic32 — Serial Terminal (C64)</title>
    <link rel="stylesheet" href="style.css" />
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
      /* Editor unico: caret standard */
      #screen {
        outline: none;
        white-space: pre-wrap;
        word-wrap: break-word;
        min-height: 1em;
      }

      /* Stile pulsanti e controlli come menù */
      .controls {
        display: flex;
        gap: 10px 14px;
        flex-wrap: wrap;
        justify-content: center;
        margin: 14px 0 6px;
      }
      .controls button,
      .controls select {
        padding: .45rem .8rem;
        border: 3px solid var(--c64-border);
        border-radius: 8px;
        background: rgba(0,0,0,.12);
        color: var(--c64-text);
        font-family: 'VT323', monospace;
        font-size: 22px;          /* uguale al menù */
        text-transform: uppercase;
        letter-spacing: 2px;
        cursor: pointer;
        transition: transform .08s ease, filter .2s ease;
      }
      .controls button:hover,
      .controls select:hover {
        transform: translateY(-2px);
        filter: brightness(1.15);
      }
      .controls label {
        color: var(--c64-text);
        font-size: 22px;          /* uguale al menù */
        letter-spacing: 2px;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .controls input[type="checkbox"] {
        accent-color: var(--c64-border);
        transform: scale(1.1);
      }

      @media (max-width: 640px) {
        .controls button,
        .controls select,
        .controls label { font-size: 20px; }
      }
    </style>
  </head>
  <body class="c64">
    <div class="crt"></div>

    <div class="frame">
      <!-- Logo + menu -->
      <a class="brand" href="index.html" aria-label="Home">
        <img src="https://raw.githubusercontent.com/Ferrazzi/Basic32/main/Logo.png" alt="Logo" />
      </a>
      <nav class="topnav" role="navigation" aria-label="primary">
        <a class="navitem" href="index.html">Home</a>
        <a class="navitem" href="terminal.html">Serial Monitor</a>
      </nav>

      <main class="content" style="padding-top: 20px;">
        <h1>TERMINALE SERIALE</h1>
        <p class="lead">
          Seleziona il dispositivo seriale: la connessione parte automaticamente.<br />
          All’aggancio invio <b>REBOOT</b> al dispositivo. Line end di default: <b>none</b>.
        </p>

        <!-- Tutti i controlli sopra -->
        <div class="controls">
          <button id="pick">Seleziona dispositivo</button>
          <button id="disconnect" disabled>Scollega</button>

          <label>
            Baud
            <select id="baud">
              <option>921600</option>
              <option>460800</option>
              <option selected>115200</option>
              <option>57600</option>
              <option>38400</option>
              <option>19200</option>
              <option>9600</option>
            </select>
          </label>

          <label>
            Line end
            <select id="lineend">
              <option value="" selected>(none)</option>
              <option value="\n">LF</option>
              <option value="\r">CR</option>
              <option value="\r\n">CRLF</option>
            </select>
          </label>

          <label>
            <input type="checkbox" id="autoscroll" checked />
            Auto-scroll
          </label>

          <button id="cls">Clear</button>
          <button id="save">Save log</button>
        </div>

        <!-- Output -->
        <div id="log" style="
          width:min(980px, 96%);
          height:420px; border:3px solid var(--c64-border); border-radius:10px;
          padding:.75rem; overflow:auto; background: rgba(0,0,0,.12); color: var(--c64-text);
          font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; text-align:left;">
          <pre id="screen" contenteditable="true" spellcheck="false" style="margin:0;">[ready]</pre>
        </div>

        <p class="hint">Serve Chrome/Edge su HTTPS (GitHub Pages) o <code>localhost</code>.</p>
      </main>

      <!-- Icone social -->
      <aside class="social">
        <a class="icon" href="https://t.me/Basic32ESP" target="_blank" rel="noopener" aria-label="Telegram">
          <!-- SVG Telegram (già presente nella tua pagina principale) -->
        </a>
        <a class="icon" href="https://github.com/Ferrazzi" target="_blank" rel="noopener" aria-label="GitHub">
          <!-- SVG GitHub (già presente nella tua pagina principale) -->
        </a>
      </aside>
    </div>

    <script type="module">
      if (!('serial' in navigator)) {
        alert('Questo browser non supporta la Web Serial API. Usa Chrome/Edge su desktop.');
      }

      const $ = (id) => document.getElementById(id);
      const pickBtn = $('pick');
      const disconnectBtn = $('disconnect');
      const baudSel = $('baud');
      const lineendSel = $('lineend');
      const autoscroll = $('autoscroll');
      const logBox = $('log');
      const screenEl = $('screen');
      const clearBtn = $('cls');
      const saveBtn = $('save');

      let port = null;
      let reader = null;
      let writer = null;
      let keepReading = false;

      /* ---- Caret helpers robusti ---- */
      function getCaretIndex() {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) return screenEl.textContent.length;
        const range = sel.getRangeAt(0);
        const preRange = document.createRange();
        preRange.selectNodeContents(screenEl);
        preRange.setEnd(range.startContainer, range.startOffset);
        return preRange.toString().length;
      }

      function setCaretIndex(index) {
        index = Math.max(0, Math.min(index, screenEl.textContent.length));
        const walker = document.createTreeWalker(screenEl, NodeFilter.SHOW_TEXT, null);
        let pos = 0, node;
        while ((node = walker.nextNode())) {
          const nextPos = pos + node.nodeValue.length;
          if (index <= nextPos) {
            const offset = index - pos;
            const range = document.createRange();
            range.setStart(node, offset);
            range.collapse(true);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            return;
          }
          pos = nextPos;
        }
        // fallback: alla fine
        const range = document.createRange();
        range.selectNodeContents(screenEl);
        range.collapse(false);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }

      function focusEditor(moveToEnd = false) {
        screenEl.focus();
        if (moveToEnd) setCaretIndex(screenEl.textContent.length);
      }

      /* ---- Output helpers ---- */
      function appendText(text) {
        // Append sempre in coda e mantieni il caret in fondo
        screenEl.textContent += text;
        setCaretIndex(screenEl.textContent.length);
        ensureBlankLineAtEnd();
        if (autoscroll.checked) logBox.scrollTop = logBox.scrollHeight;
      }

      function localClear() {
        screenEl.textContent = '';
        // dopo clear, lasciamo una riga vuota pronta
        ensureBlankLineAtEnd();
        setCaretIndex(screenEl.textContent.length);
      }

      function logLine(txt) {
        const t = screenEl.textContent.replace(/\s*$/, ''); // rimuovo spazi finali
        screenEl.textContent = (t.length ? t + '\n' : '') + txt + '\n';
        ensureBlankLineAtEnd(); // aggiunge la riga vuota in fondo
        setCaretIndex(screenEl.textContent.length);
        if (autoscroll.checked) logBox.scrollTop = logBox.scrollHeight;
      }

      /* ---- ANSI: ESC[2J clear + home, ESC[H home ---- */
      function handleAnsiAndAppend(chunk) {
        if (/\x1b\[2J/.test(chunk)) {
          localClear();
          chunk = chunk.replace(/\x1b\[2J/g, '');
        }
        if (/\x1b\[H/.test(chunk)) {
          // posiziona il cursore logico a inizio; dopo invio torniamo comunque in fondo
          setCaretIndex(0);
          chunk = chunk.replace(/\x1b\[H/g, '');
        }
        appendText(chunk);
      }

      /* ---- Invio su seriale ---- */
      async function writeWithLineEnd(str) {
        if (!writer) return;
        const encoder = new TextEncoder();
        const end = lineendSel.value || '';
        await writer.write(encoder.encode(str + end));
      }

      // Garantisce che il testo termini con UNA riga vuota (due newline finali)
      function ensureBlankLineAtEnd() {
        if (screenEl.textContent.endsWith('\n\n')) return;
        if (screenEl.textContent.endsWith('\n')) {
          screenEl.textContent += '\n';
        } else {
          screenEl.textContent += '\n\n';
        }
      }

      // Invia la riga corrente; poi metti SEMPRE il cursore su una NUOVA riga vuota in fondo
      async function sendCurrentLine() {
        const txt = screenEl.textContent;
        const idx = getCaretIndex();
        const lineStart = txt.lastIndexOf('\n', Math.max(0, idx - 1)) + 1;
        const lineEnd = txt.indexOf('\n', idx);
        const endIdx = (lineEnd === -1) ? txt.length : lineEnd;
        const line = txt.slice(lineStart, endIdx);

        await writeWithLineEnd(line);

        // Non tocchiamo le righe sopra; assicuriamo una riga vuota in fondo e mettiamo il caret lì
        ensureBlankLineAtEnd();
        setCaretIndex(screenEl.textContent.length);
        if (autoscroll.checked) logBox.scrollTop = logBox.scrollHeight;
      }

      /* ---- Hotkeys ---- */
      screenEl.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          await sendCurrentLine();
        }
      });

      /* ---- UI wiring ---- */
      pickBtn.addEventListener('click', async () => {
        try {
          port = await navigator.serial.requestPort();
        } catch {
          logLine('[selezione annullata]');
          return;
        }
        await connectSerial();
      });

      async function connectSerial() {
        try {
          await port.open({ baudRate: Number(baudSel.value) || 115200 });
          const decoder = new TextDecoder();
          reader = port.readable.getReader();
          writer = port.writable.getWriter();
          keepReading = true;

          localClear();
          logLine('[connesso — invio comando REBOOT]');
          await writeWithLineEnd('REBOOT');
          disconnectBtn.disabled = false;
          focusEditor(true);

          (async () => {
            try {
              while (keepReading) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                  const chunk = decoder.decode(value);
                  handleAnsiAndAppend(chunk);
                }
              }
            } finally {
              try { reader.releaseLock(); } catch {}
            }
          })();
        } catch (e) {
          alert('Connessione fallita: ' + e);
        }
      }

      async function disconnect() {
        keepReading = false;
        try { if (reader) await reader.cancel(); } catch {}
        try { if (writer) writer.releaseLock(); } catch {}
        try { if (port) await port.close(); } catch {}
        disconnectBtn.disabled = true;
        logLine('[disconnesso]');
        focusEditor(false);
      }
      disconnectBtn.addEventListener('click', disconnect);
      window.addEventListener('beforeunload', () => { if (port) disconnect(); });

      clearBtn.addEventListener('click', () => {
        localClear();
        logLine('[clear]');
        focusEditor(true);
      });

      saveBtn.addEventListener('click', () => {
        const blob = new Blob([screenEl.textContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'serial-log.txt'; a.click();
        URL.revokeObjectURL(url);
      });

      // avvio: riga vuota pronta e caret in fondo
      ensureBlankLineAtEnd();
      focusEditor(true);
    </script>
  </body>
</html>
