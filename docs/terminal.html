<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Basic32 — Serial Terminal (C64)</title>
    <link rel="stylesheet" href="style.css" />
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
      /* Nessun cursore custom */
      #entry {
        display: inline-block;
        min-height: 1em;
        outline: none;
        white-space: pre;
      }
    </style>
  </head>
  <body class="c64">
    <div class="crt"></div>

    <div class="frame">
      <!-- Logo + menu -->
      <a class="brand" href="index.html" aria-label="Home">
        <img src="https://raw.githubusercontent.com/Ferrazzi/Basic32/main/Logo.png" alt="Logo" />
      </a>
      <nav class="topnav" role="navigation" aria-label="primary">
        <a class="navitem" href="index.html">Home</a>
        <a class="navitem" href="terminal.html">Serial Monitor</a>
      </nav>

      <main class="content" style="padding-top: 60px;">
        <h1>TERMINALE SERIALE</h1>
        <p class="lead">
          Seleziona il dispositivo seriale: la connessione parte automaticamente.<br />
          All’aggancio invio <b>REBOOT</b> al dispositivo. Line end di default: <b>none</b>.
        </p>

        <!-- Controlli -->
        <div class="controls" style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin:14px 0 6px;">
          <button id="pick">Seleziona dispositivo</button>
          <button id="disconnect" disabled>Scollega</button>

          <label>
            Baud
            <select id="baud">
              <option>921600</option>
              <option>460800</option>
              <option selected>115200</option>
              <option>57600</option>
              <option>38400</option>
              <option>19200</option>
              <option>9600</option>
            </select>
          </label>

          <label>
            Line end
            <select id="lineend">
              <option value="" selected>(none)</option>
              <option value="\n">LF</option>
              <option value="\r">CR</option>
              <option value="\r\n">CRLF</option>
            </select>
          </label>

          <label style="display:flex;align-items:center;gap:6px;">
            <input type="checkbox" id="autoscroll" checked />
            Auto-scroll
          </label>

          <button id="cls">Clear</button>
          <button id="save">Save log</button>
        </div>

        <!-- Output + Input nello stesso riquadro -->
        <div id="log" style="
          width:min(980px, 96%);
          height:420px; border:3px solid var(--c64-border); border-radius:10px;
          padding:.75rem; overflow:auto; background: rgba(0,0,0,.12); color: var(--c64-text);
          font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; text-align:left;">
          <pre id="out" style="margin:0; white-space:pre-wrap; word-wrap:break-word;">[ready]</pre>
          <div id="entry" contenteditable="true" spellcheck="false"></div>
        </div>

        <p class="hint">Serve Chrome/Edge su HTTPS (GitHub Pages) o <code>localhost</code>.</p>
      </main>

      <!-- Icone social -->
      <aside class="social">
        <a class="icon" href="https://t.me/Basic32ESP" target="_blank" rel="noopener" aria-label="Telegram">
          <!-- Telegram SVG -->
        </a>
        <a class="icon" href="https://github.com/Ferrazzi" target="_blank" rel="noopener" aria-label="GitHub">
          <!-- GitHub SVG -->
        </a>
      </aside>
    </div>

    <script type="module">
      if (!('serial' in navigator)) {
        alert('Questo browser non supporta la Web Serial API. Usa Chrome/Edge su desktop.');
      }

      const $ = (id) => document.getElementById(id);
      const pickBtn = $('pick');
      const disconnectBtn = $('disconnect');
      const baudSel = $('baud');
      const lineendSel = $('lineend');
      const autoscroll = $('autoscroll');
      const logBox = $('log');
      const outEl = $('out');
      const entryEl = $('entry');
      const clearBtn = $('cls');
      const saveBtn = $('save');

      let port = null;
      let reader = null;
      let writer = null;
      let keepReading = false;

      function focusEntry() {
        entryEl.focus();
        const sel = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(entryEl);
        range.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range);
      }

      function renderAppend(text) {
        outEl.textContent += text;
        if (autoscroll.checked) logBox.scrollTop = logBox.scrollHeight;
      }
      function localClear() {
        outEl.textContent = '';
        focusEntry();
      }
      function logLine(txt) {
        renderAppend((outEl.textContent.endsWith('\n') ? '' : '\n') + txt + '\n');
      }

      function handleAnsiAndAppend(chunk) {
        chunk = chunk.replace(/\x1b\[2J/g, () => { localClear(); return ''; });
        chunk = chunk.replace(/\x1b\[H/g, () => { return ''; });
        renderAppend(chunk);
      }

      async function writeWithLineEnd(str) {
        if (!writer) return;
        const encoder = new TextEncoder();
        const end = lineendSel.value || '';
        await writer.write(encoder.encode(str + end));
      }

      entryEl.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          const cmd = entryEl.textContent;
          entryEl.textContent = '';
          renderAppend((outEl.textContent.endsWith('\n') ? '' : '\n') + cmd + '\n');
          await writeWithLineEnd(cmd);
          focusEntry();
        }
      });

      logBox.addEventListener('mousedown', (e) => {
        if (e.target !== entryEl) {
          e.preventDefault();
          focusEntry();
        }
      });

      pickBtn.addEventListener('click', async () => {
        try {
          port = await navigator.serial.requestPort();
          await connectSerial();
        } catch {
          logLine('[selezione annullata]');
        }
      });

      async function connectSerial() {
        try {
          await port.open({ baudRate: Number(baudSel.value) || 115200 });
          const decoder = new TextDecoder();
          reader = port.readable.getReader();
          writer = port.writable.getWriter();
          keepReading = true;
          localClear();
          logLine('[connesso — invio comando REBOOT]');
          await writeWithLineEnd('REBOOT');
          disconnectBtn.disabled = false;
          focusEntry();
          (async () => {
            try {
              while (keepReading) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                  const chunk = decoder.decode(value);
                  handleAnsiAndAppend(chunk);
                  focusEntry();
                }
              }
            } finally {
              try { reader.releaseLock(); } catch {}
            }
          })();
        } catch (e) {
          alert('Connessione fallita: ' + e);
        }
      }

      async function disconnect() {
        keepReading = false;
        try { if (reader) await reader.cancel(); } catch {}
        try { if (writer) writer.releaseLock(); } catch {}
        try { if (port) await port.close(); } catch {}
        disconnectBtn.disabled = true;
        logLine('[disconnesso]');
        focusEntry();
      }
      disconnectBtn.addEventListener('click', disconnect);
      window.addEventListener('beforeunload', () => { if (port) disconnect(); });

      clearBtn.addEventListener('click', () => { localClear(); focusEntry(); });
      saveBtn.addEventListener('click', () => {
        const blob = new Blob([outEl.textContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'serial-log.txt'; a.click();
        URL.revokeObjectURL(url);
      });

      focusEntry();
    </script>
  </body>
</html>
