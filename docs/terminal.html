<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Basic32 — Serial Monitor</title>
    <link rel="stylesheet" href="style.css" />
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
      /* Editor unico: caret standard, nessun cursore custom */
      #screen {
        outline: none;
        white-space: pre-wrap;
        word-wrap: break-word; /* NON aggiungiamo newline, permette il wrap solo visivo */
        min-height: 1em;
      }
    </style>
  </head>
  <body class="c64">
    <div class="crt"></div>

    <div class="frame">
      <!-- Logo + menu -->
      <a class="brand" href="index.html" aria-label="Home">
        <img src="https://raw.githubusercontent.com/Ferrazzi/Basic32/main/Logo.png" alt="Logo" />
      </a>
      <nav class="topnav" role="navigation" aria-label="primary">
        <a class="navitem" href="index.html">Flash</a>
        <a class="navitem" href="terminal.html">Serial Monitor</a>
      </nav>

      <main class="content" style="padding-top: 10px;">
        <h1>SERIAL MONITOR</h1>
        <p class="lead">
          Select the serial device: the connection starts automatically.<br />
        </p>

        <!-- Controlli -->
        <div class="controls" style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin:14px 0 6px;">
          <button id="pick">Select device</button>
          <button id="disconnect" disabled>Disconnect</button>

          <label>
            Baud
            <select id="baud">
              <option>921600</option>
              <option>460800</option>
              <option selected>115200</option>
              <option>57600</option>
              <option>38400</option>
              <option>19200</option>
              <option>9600</option>
            </select>
          </label>

          <label>
            Line end
            <select id="lineend">
              <option value="" selected>(none)</option>
              <option value="\n">LF</option>
              <option value="\r">CR</option>
              <option value="\r\n">CRLF</option>
            </select>
          </label>

          <label style="display:flex;align-items:center;gap:6px;">
            <input type="checkbox" id="autoscroll" checked />
            Auto-scroll
          </label>

          <button id="cls">Clear</button>
          <button id="save">Save log</button>
        </div>

        <!-- Unica area: output + editing libero -->
        <div id="log" style="
          width:min(980px, 96%);
          height:420px; border:3px solid var(--c64-border); border-radius:10px;
          padding:.75rem; overflow:auto; background: rgba(0,0,0,.12); color: var(--c64-text);
          font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; text-align:left;">
          <pre id="screen" contenteditable="true" spellcheck="false" style="margin:0;">[ready]</pre>
        </div>

        <p class="hint">Chrome/Edge over HTTPS is required</p>
      </main>

      <!-- Icone social -->
      <aside class="social">
        <a class="icon" href="https://t.me/Basic32ESP" target="_blank" rel="noopener" aria-label="Telegram">
          <svg viewBox="0 0 240 240" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <defs><linearGradient id="tg" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0%" stop-color="#37aee2"/><stop offset="100%" stop-color="#1e96c8"/>
            </linearGradient></defs>
            <circle cx="120" cy="120" r="120" fill="url(#tg)"/>
            <path fill="#c8daea" d="M98 163c-3 0-2-1-3-4l-8-26 74-44"/>
            <path fill="#a9c9dd" d="M98 163c2 0 4-1 6-3l16-15-20-12"/>
            <path fill="#fff" d="M100 133l48 35c5 3 8 1 9-5l16-75c2-8-3-11-8-9L66 109c-8 3-8 7-1 9l24 7 55-35c3-2 6-1 4 1"/>
          </svg>
        </a>
        <a class="icon" href="https://github.com/Ferrazzi" target="_blank" rel="noopener" aria-label="GitHub">
          <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path fill="currentColor" fill-rule="evenodd"
              d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38
                 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53
                 .63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95
                 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27
                 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95
                 .29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8Z"/>
          </svg>
        </a>
      </aside>
    </div>

    <script type="module">
      if (!('serial' in navigator)) {
        alert('This browser does not support the Web Serial API. Use Chrome/Edge on desktop.');
      }

      const $ = (id) => document.getElementById(id);
      const pickBtn = $('pick');
      const disconnectBtn = $('disconnect');
      const baudSel = $('baud');
      const lineendSel = $('lineend');
      const autoscroll = $('autoscroll');
      const logBox = $('log');
      const screenEl = $('screen');
      const clearBtn = $('cls');
      const saveBtn = $('save');

      let port = null;
      let reader = null;
      let writer = null;
      let keepReading = false;

      // Utils caret ↔ indice carattere nell'editor
      function getCaretIndex() {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) return screenEl.textContent.length;
        const range = sel.getRangeAt(0);
        const preRange = document.createRange();
        preRange.selectNodeContents(screenEl);
        preRange.setEnd(range.startContainer, range.startOffset);
        return preRange.toString().length;
      }

      function setCaretIndex(index) {
        index = Math.max(0, Math.min(index, screenEl.textContent.length));
        const walker = document.createTreeWalker(screenEl, NodeFilter.SHOW_TEXT, null);
        let pos = 0, node;
        while ((node = walker.nextNode())) {
          const nextPos = pos + node.nodeValue.length;
          if (index <= nextPos) {
            const offset = index - pos;
            const range = document.createRange();
            range.setStart(node, offset);
            range.collapse(true);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            return;
          }
          pos = nextPos;
        }
        // fallback: alla fine
        const range = document.createRange();
        range.selectNodeContents(screenEl);
        range.collapse(false);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }

      function focusEditor(moveToEnd = false) {
        screenEl.focus();
        if (moveToEnd) setCaretIndex(screenEl.textContent.length);
      }

      // --- Garantisce UNA riga vuota a fine testo e porta il caret lì
      function ensureTrailingBlankLineInEditor() {
        const t = screenEl.textContent;
        let s = t;
        if (s.endsWith('\n\n')) {
          // ok
        } else if (s.endsWith('\n')) {
          s += '\n';
        } else {
          s += '\n\n';
        }
        if (s !== t) screenEl.textContent = s;
        setCaretIndex(screenEl.textContent.length);
        if (autoscroll.checked) logBox.scrollTop = logBox.scrollHeight;
      }

      // Output helpers
      function appendText(text) {
        // *** NON aggiungiamo newline qui, per non spezzare output in chunk ***
        const atEnd = getCaretIndex() === screenEl.textContent.length;
        screenEl.textContent += text;
        if (atEnd) setCaretIndex(screenEl.textContent.length);
        if (autoscroll.checked) logBox.scrollTop = logBox.scrollHeight;
      }

      function localClear() {
        screenEl.textContent = '';
        setCaretIndex(0);
      }

      function logLine(txt) {
        // Messaggi locali: una sola newline di chiusura
        const t = screenEl.textContent;
        screenEl.textContent = (t.endsWith('\n') || t.length === 0 ? t : t + '\n') + txt + '\n';
        setCaretIndex(screenEl.textContent.length);
        if (autoscroll.checked) logBox.scrollTop = logBox.scrollHeight;
      }

      // ANSI: ESC[2J clear + home, ESC[H home
      function handleAnsiAndAppend(chunk) {
        if (/\x1b\[2J/.test(chunk)) {
          localClear();
          chunk = chunk.replace(/\x1b\[2J/g, '');
        }
        if (/\x1b\[H/.test(chunk)) {
          setCaretIndex(0);
          chunk = chunk.replace(/\x1b\[H/g, '');
        }

        // Appendi il testo così com'è
        appendText(chunk);

        // Se il chunk termina con newline, allora portiamo il caret su una nuova riga
        if (chunk.endsWith('\n')) {
          ensureTrailingBlankLineInEditor();
        }
      }

      // Aggiunge line end e invia
      async function writeWithLineEnd(str) {
        if (!writer) return;
        const encoder = new TextEncoder();
        const end = lineendSel.value || '';
        await writer.write(encoder.encode(str + end));
      }

      // garantisce che il testo termini con UNA riga vuota (due newline finali)
      function ensureTrailingBlankLine(s) {
        if (s.endsWith('\n\n')) return s;
        if (s.endsWith('\n')) return s + '\n';
        return s + '\n\n';
      }

      // Invia la riga corrente, poi porta SEMPRE il cursore su una NUOVA riga in fondo
      async function sendCurrentLine() {
        const idx = getCaretIndex();
        const txt = screenEl.textContent;
        const lineStart = txt.lastIndexOf('\n', Math.max(0, idx - 1)) + 1;
        const lineEnd = txt.indexOf('\n', idx);
        const endIdx = (lineEnd === -1) ? txt.length : lineEnd;
        const line = txt.slice(lineStart, endIdx);

        await writeWithLineEnd(line);

        // Forza una riga vuota in fondo e sposta il caret lì
        screenEl.textContent = ensureTrailingBlankLine(txt);
        ensureTrailingBlankLineInEditor();
      }

      // Key handling: Enter invia la riga corrente e porta il cursore su riga nuova in fondo
      screenEl.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          await sendCurrentLine();
        }
      });

      // Click nel box mantiene il focus nell'editor
      logBox.addEventListener('mousedown', () => { setTimeout(() => focusEditor(false), 0); });

      // Device picker → auto-connect
      pickBtn.addEventListener('click', async () => {
        try {
          port = await navigator.serial.requestPort();
        } catch {
          logLine('[Selection canceled]');
          return;
        }
        await connectSerial();
      });

      async function connectSerial() {
        try {
          await port.open({ baudRate: Number(baudSel.value) || 115200 });
          const decoder = new TextDecoder();
          reader = port.readable.getReader();
          writer = port.writable.getWriter();
          keepReading = true;

          localClear();
          logLine('[Connected — sending REBOOT command]');
          await writeWithLineEnd('REBOOT');
          disconnectBtn.disabled = false;
          focusEditor(true);

          (async () => {
            try {
              while (keepReading) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                  const chunk = decoder.decode(value);
                  handleAnsiAndAppend(chunk);
                }
              }
            } finally {
              try { reader.releaseLock(); } catch {}
            }
          })();
        } catch (e) {
          alert('Connection failed: ' + e);
        }
      }

      // Disconnessione
      async function disconnect() {
        keepReading = false;
        try { if (reader) await reader.cancel(); } catch {}
        try { if (writer) writer.releaseLock(); } catch {}
        try { if (port) await port.close(); } catch {}
        disconnectBtn.disabled = true;
        logLine('[disconnected]');
        focusEditor(false);
      }
      disconnectBtn.addEventListener('click', disconnect);
      window.addEventListener('beforeunload', () => { if (port) disconnect(); });

      // Utility
      clearBtn.addEventListener('click', () => { localClear(); focusEditor(false); });
      saveBtn.addEventListener('click', () => {
        const blob = new Blob([screenEl.textContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'serial-log.txt'; a.click();
        URL.revokeObjectURL(url);
      });

      // avvio
      focusEditor(true);
    </script>
  </body>
</html>
